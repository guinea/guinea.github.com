---
layout: post
title: Efficient procedural landscapes on the iPhone
---

Anyone who has ever watched Baywatch knows how well great scenery can cover up a lame script.  We weren't anticipating poor gameplay, but when we set out to write Firmament, conceived as a cross between the classic Elite, and XGen's motherload, we wanted to set the game in a vast world, and allow the player to explore it.  We wanted this world to look great, we wanted it to be smoothly rendered, and we knew we didn't have the resources to geneate the scenery by hand.  Procedurally generating this landscape on the fly was the clear solution.  Much has been written on procedural landscape generation, but little on the challenges specific to using it in a real game.  In this article I will discuss how we built a rendering engine to create Firmament's endless and deformable landscape, and what we would do differently next time.

[pictures of sahara, mountains, rolling hills]

For simplicity we chose to implement the landscape as a heightmap.  Caves and arches would have been spectacular, but generating such a landscape is much harder.  For the mathematicians out there, the landscape could be described as a scalar field over the 2D plane.  The challenge was to   The cornerstone of this type of landscape is Perlin Noise.

A naive approach to generating a landscape would be to randomly assign all points on the landscape plane a height, giving a spiky and chaotic appearance.  Needless to say the real world does not look like this.  Perlin noise allows you to add random variation to the landscape by wavelength.  To generate rolling hills you want random noise with a long wavelength and small amplitude, whereas mountains have large amplitude but a short wavelength.  To paint the surface one chooses a colour palette and fades between the colours according to height, and of course a random Perlin variation.  It is an art, but with practice it is straightforward to generate convincing landscapes ranging from deserts to mountains to rolling hills in this manner.

These calculations are far too intensive to implement in realtime.  Even on a desktop generating Perlin noise is too computationally to be possible frame to frame; clearly we required a cache.

Our first step was to chop the landscape into tiles of 36 vertices each.  As a tile enters the field of view it is added to the landscape generator's TODO list, and when its memory is required the tile is destroyed.  We allowed only one tile be generated per frame to avoid visual juddering.  This limits the speed at which a player can move and still find a landscape beneath him, but with all parameters carefully tuned, and some fog to mask the sudden appearance of landscape tiles we achieved smooth flight through the world on even the oldest hardware.

A further feature we wanted for our landscape was deformability.  Part of the game entails mining for minerals, and we wanted players to be able to dig a hole in the ground, fly away and stumble across their handiwork later on.  This was surprisingly painless; as a player mines, the cached tiles are deformed, and the deformations are stored so that they can be restored when the tile is rebuilt.

Early on we experimented with a variable mesh density, making it finely grained close to the player, and coarse grained in the distance.  The extra overhead required to achieve this almost entirely negated the speed increase from drawing the background at lower resolution, but its fatal weakness was the transition from low to high resolution.  The first rule of writing a graphics engine is to do nothing that jars the eye, and we were unable to either mask or animate the transition, so it was discarded.

That is how we built our landscape engine.  Before mentioning what we would do next time to improve it I would like to touch on a few performance tips.   The ARM core inside every iOS device understands both its native armv6/armv7 instruction set as well as Thumb code.  The Thumb instruction set is 16 bits wide in comparison to the native 32, allowing for reduced code size and enhanced execution speed, however it does not support floating point operations, and requires the processor to switch mode before executing floating point instructions.  By default xcode compiles for Thumb, and with Firmament being so heavily reliant on floating point operations, merely unchecking this option doubled the speed of landscape generation, our major bottleneck.  A feature of the processor we did not take advantage of was the vectored nature of the floating point processor, which allows it to carry out four identical operations simultaneously.  The effort to recode portions of the engine in assembly to exploit the iPhone's VFP may well have been worth it.

The first change I would make if I started again is that the distribution function, which selects the landscape type at each point in the world would be hardcoded by a bitmap, allowing us to design the layout of the world.  This was one of the times we got caught up in the elegance and purity of the landscape generation.  An endless, procedurally generated, landscape resulting from a Perlin based distribution function is mathematically appealing, but it is also empty and devoid of character.  Was the the world in GTA San Andreas appealing solely because it was vast? or because it was packed with details - minigames, jumps, hidden secrets - that brought it alive?  In general, be careful to use procedural generation to render the details, and not as a lazy way to attempt to generate an entire game.

Programmable pipeline.  Back in early 2010 when work started on Firmament, many potential customers were still using iPhone 3g generation hardware, so rather than alienate them with a single #include statement, we stuck with the fixed pipeline graphics of gles 1.  I'd love to rewrite the renderer with pixel shaders, and see how much procedural texture we could add to Firmament's clinically stark colour shading.

There was a period in development when the water moved in waves.  Two minutes with the profiler put an end to that; the processor load was unacceptable compared with the minimal benefit.  Nevertheless, details make the game, and with vertex shaders we could shunt that processing to the GPU, leaving the CPU to generate the landscape.  Waves could appear on the sea, lava could pulsate and glow, and sand dunes could move.

A weakness of pure Perlin noise landscapes is they do not look weathered.  Mountains should not be smooth.  This is easily fixed by applying the diamond star algorithm, a recursive method which involves subdividing the grid, and randomly perturbing the new vertices in order to generate a more realistic looking surface.  It didn't make it into Firmament for performance reasons, but the current generation of mobile devices are powerful enough to support diamond-star weathering.
